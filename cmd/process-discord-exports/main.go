package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"slices"
	"strconv"
	"strings"
	"time"
	"unicode"

	"github.com/icedream/hololive-bettel-royale-data-processing/internal/database"
	"github.com/icedream/hololive-bettel-royale-data-processing/internal/discord"
	_ "github.com/mattn/go-sqlite3"
	"gorm.io/gorm"
)

const (
	mainChannelID     = `1224009923457847428`
	botAuthorID       = `693167035068317736`
)

type backupFile struct {
	firstMessageTime time.Time
	file             *os.File
}

func main() {
	if len(os.Args) < 2 {
		log.Fatal("Need a subcommand to execute")
	}

	db, err := database.OpenSQLite("main.db")
	if err != nil {
		panic(err)
	}

	switch os.Args[1] {
	case "dump":
		if err := runDump(db); err != nil {
			panic(err)
		}

	case "import":
		if err := runImport(db); err != nil {
			panic(err)
		}

	case "reset":
		if err := db.AutoMigrate(); err != nil {
			panic(err)
		}
		if err := db.Export(os.Stdout); err != nil {
			panic(err)
		}

	default:
		log.Fatal("Invalid subcommand")
	}
}

type Processor struct {
	db *database.Database

	LastKnownIsGameRunning bool
	LastKnownGame          database.Game
	LastKnownRound         database.Round
}

func runDump(db *database.Database) error {
	if _, err := os.Stdout.WriteString(`--
-- Hololive Battle Royale statistics dump
--
-- This dump is entirely compatible with SQLite.
--
-- DO NOT EDIT. This was autogenerated by a tool.
--

`); err != nil {
		return err
	}

	if err := db.Export(os.Stdout); err != nil {
		return err
	}

	return nil
}

func runImport(db *database.Database) error {
	if err := db.AutoMigrate(); err != nil {
		return err
	}

	backupFiles := []backupFile{}

	// extract timestamps from each discord export
	if err := filepath.Walk("discord-exports/"+mainChannelID, func(path string, info fs.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}
		r, err := os.OpenFile(path, os.O_RDONLY, 0o400)
		if err != nil {
			return err
		}
		// r will be closed in second loop

		// only extract first message timestamp for sorting
		var backup struct {
			Messages []struct {
				Timestamp time.Time `json:"timestamp"`
			} `json:"messages"`
		}
		if err := json.NewDecoder(r).Decode(&backup); err != nil {
			return err
		}
		if _, err := r.Seek(0, io.SeekStart); err != nil {
			return err
		}

		firstMessage := backup.Messages[0]
		backupFiles = append(backupFiles, backupFile{
			file:             r,
			firstMessageTime: firstMessage.Timestamp,
		})

		return nil
	}); err != nil {
		return err
	}

	// sort backups by which timestamps they start from so they are linear history
	slices.SortFunc(backupFiles, func(a, b backupFile) int {
		if a.firstMessageTime == b.firstMessageTime {
			return 0
		}
		if a.firstMessageTime.After(b.firstMessageTime) {
			return 1
		}
		return -1
	})

	// actually process the backups
	p := newProcessor(db)
	for _, backupFile := range backupFiles {
		var backup discord.Backup
		if err := json.NewDecoder(backupFile.file).Decode(&backup); err != nil {
			return fmt.Errorf("failed to parse message export %s: %w", backupFile.file.Name(), err)
		}
		backupFile.file.Close()
		if err := p.processExport(backup); err != nil {
			return fmt.Errorf("failure in message export %s: %w", backupFile.file.Name(), err)
		}
	}

	return nil
}

func newProcessor(db *database.Database) *Processor {
	return &Processor{
		db: db,
	}
}

func (p *Processor) storeCurrentGame() error {
	tx := p.db.GORM().Save(&p.LastKnownGame)
	if tx.Error != nil {
		return tx.Error
	}
	return nil
}

func (p *Processor) storeCurrentRound() error {
	tx := p.db.GORM().Create(&p.LastKnownRound)
	if tx.Error != nil {
		return tx.Error
	}
	return nil
}

func (p *Processor) storeInteraction(i *database.Interaction) error {
	tx := p.db.GORM().Create(i)
	if tx.Error != nil {
		return tx.Error
	}
	return nil
}

func (p *Processor) storeUser(u *database.User) error {
	tx := p.db.GORM().Save(u)
	if tx.Error != nil {
		return tx.Error
	}
	return nil
}

func (p *Processor) lookupUser(name string) (database.User, error) {
	u := database.User{}
	if len(name) == 0 {
		return u, errors.New("empty username")
	}
	tx := p.db.GORM().
		Where("name = ?", name).
		First(&u)
	err := tx.Error
	if errors.Is(err, gorm.ErrRecordNotFound) {
		err = nil
	}
	if err != nil {
		return u, err
	}
	if tx.RowsAffected == 0 {
		u.Name = name
		err = p.storeUser(&u)
	}
	return u, err
}

func (p *Processor) storeItem(i *database.Item) error {
	tx := p.db.GORM().Save(i)
	if tx.Error != nil {
		return tx.Error
	}
	return nil
}

func (p *Processor) lookupItem(name string) (database.Item, error) {
	i := database.Item{}
	tx := p.db.GORM().
		Where("name = ?", name).
		First(&i)
	err := tx.Error
	if errors.Is(err, gorm.ErrRecordNotFound) {
		err = nil
	}
	if err != nil {
		return i, err
	}
	if tx.RowsAffected == 0 {
		i.Name = name
		err = p.storeItem(&i)
	}
	return i, err
}

func (p *Processor) storeInteractionMessage(i *database.InteractionMessage) error {
	tx := p.db.GORM().Save(i)
	if tx.Error != nil {
		return tx.Error
	}
	return nil
}

func (p *Processor) lookupInteractionMessage(text, event string) (database.InteractionMessage, error) {
	i := database.InteractionMessage{
		Text:  text,
		Event: event,
	}
	tx := p.db.GORM().
		Where("text = ?", text).
		Where("event = ?", event).
		First(&i)
	err := tx.Error
	if errors.Is(err, gorm.ErrRecordNotFound) {
		err = nil
	}
	if err != nil {
		return i, err
	}
	if tx.RowsAffected == 0 {
		i.Text = text
		i.Event = event
		err = p.storeInteractionMessage(&i)
	}
	return i, err
}

func (p *Processor) wrapError(msg discord.Message, err error) error {
	err = fmt.Errorf("failure at message ID %s: %w", msg.ID, err)
	return err
}

func (p *Processor) processExport(backup discord.Backup) error {
	for _, msg := range backup.Messages {
		if msg.Author.ID != botAuthorID {
			continue
		}
		if len(msg.Embeds) < 1 {
			continue
		}
		for _, embed := range msg.Embeds {
			var err error
			switch {
			case strings.Contains(embed.Title, "hosted by ") ||
				(embed.Footer != nil && embed.Footer.Text == "Automatic Session"):
				err = p.processGameCountdownStart(msg, embed)
			case strings.HasPrefix(embed.Title, "Started a new "):
				err = p.processGameStart(msg, embed)
			case strings.Contains(embed.Title, "WINNER!"):
				err = p.processGameWinner(embed)
			case strings.HasPrefix(embed.Title, "__Round "):
				err = p.processRound(embed)
			default:
				desc, userInteractions, err := p.extractUsers(embed.Description)
				if err != nil {
					return p.wrapError(msg, err)
				}
				log.Printf("ignoring unhandled message:\n\n[%s]\n\tEmbed title: %q\n\n\tEmbed description:\n\n\t%q\n\nUsernames: %+v\n\n", msg.Timestamp, embed.Title, desc, userInteractions)
			}
			if err != nil {
				return p.wrapError(msg, err)
			}
		}
	}

	return nil
}

const rxStrDiscordUsername = `([a-z0-9_\.\\]*[a-z0-9_\.])(\s+[^\*]+)?`

var rxUserFormatted = regexp.MustCompile(
	`(?:~~\*\*` + rxStrDiscordUsername + `\*\*~~|\*\*` + rxStrDiscordUsername + `\*\*)`)

func unescapeMarkdown(msg string) string {
	msg = strings.ReplaceAll(msg, `\_`, `_`)
	msg = strings.ReplaceAll(msg, `\*`, `*`)
	msg = strings.ReplaceAll(msg, `\.`, `.`)
	msg = strings.ReplaceAll(msg, `\\`, `\`)
	return msg
}

func (p *Processor) extractUsers(msg string) (string, []database.InteractionUserMention, error) {
	matches := rxUserFormatted.FindAllStringSubmatch(msg, -1)
	userInteractions := []database.InteractionUserMention{}
	for _, match := range matches {
		var userInteraction database.InteractionUserMention
		switch {
		case len(match[1]) != 0: // ~~**USERNAME SUFFIX**~~
			user, err := p.lookupUser(unescapeMarkdown(match[1]))
			if err != nil {
				return "", nil, err
			}
			userInteraction = database.InteractionUserMention{
				User:   user,
				UserID: user.Name,
				Killed: true,
				Suffix: match[2],
			}
		case len(match[3]) != 0: // **USERNAME SUFFIX**
			user, err := p.lookupUser(unescapeMarkdown(match[3]))
			if err != nil {
				return "", nil, err
			}
			userInteraction = database.InteractionUserMention{
				User:   user,
				UserID: user.Name,
				Suffix: match[4],
			}
		}
		index := slices.Index(userInteractions, userInteraction)
		if index < 0 {
			index = len(userInteractions)
			userInteractions = append(userInteractions, userInteraction)
		}
		msg = strings.Replace(msg, match[0], fmt.Sprintf(`{{users[%d]}}`, index), 1)
	}
	return msg, userInteractions, nil
}

var rxItemFormatted = regexp.MustCompile(`__([^_]+)__`)

func (p *Processor) extractItems(msg string) (string, []database.Item, error) {
	matches := rxItemFormatted.FindAllStringSubmatch(msg, -1)
	items := []database.Item{}
	if len(matches) > 1 {
		return "", nil, errors.New("more than 1 item mention found in message which is not yet supported: " + msg)
	}
	for _, match := range matches {
		item, err := p.lookupItem(unescapeMarkdown(match[1]))
		if err != nil {
			return "", nil, err
		}
		msg = strings.Replace(msg, match[0], `{{item}}`, 1)
		items = append(items, item)
	}
	return msg, items, nil
}

func filterGraphic(r rune) rune {
	if unicode.IsGraphic(r) || unicode.IsSpace(r) {
		return r
	}
	return -1
}

var rxEra = regexp.MustCompile(`(?m)Era:\s+(<:.+:.+>)?\s*([^\r\n]+?)\s*(?:$|\n)`)

func (p *Processor) createNewGame(era string, host *database.User) {
	p.LastKnownGame = database.Game{
		ID:  p.LastKnownGame.ID + 1,
		Era: era,
	}
	if host != nil {
		p.LastKnownGame.HostUser = host
		p.LastKnownGame.HostUserName = &host.Name
	}
	p.LastKnownRound = database.Round{
		GameID: p.LastKnownGame.ID,
		Game:   p.LastKnownGame,
	}
	p.LastKnownIsGameRunning = false
}

func (p *Processor) createNewRound(roundNumber int) {
	p.LastKnownRound = database.Round{
		GameID:      p.LastKnownGame.ID,
		Game:        p.LastKnownGame,
		RoundNumber: roundNumber,
	}
}

func (p *Processor) processGameCountdownStart(m discord.Message, e discord.Embed) error {
	/*
		Embed title: "Rumble Royale hosted by astelzoom"

		Embed description:

		"E\u200e\u200er\u200ea:\u200e\u200e\u200e \u200e\u200e\u200e<:wol:696302964985298964>C\u200el\u200ea\u200es\u200e\u200es\u200eic\u200e\u200e \u200e\n\u200e\u200e\n\u200eCl\u200e\u200ei\u200e\u200e\u200ec\u200e\u200ek \u200e\u200et\u200eh\u200e\u200ee \u200ee\u200e\u200e\u200em\u200e\u200eoj\u200e\u200ei\u200e\u200e\u200e \u200eb\u200ee\u200e\u200e\u200el\u200e\u200e\u200eo\u200e\u200ew\u200e\u200e \u200et\u200e\u200e\u200eo\u200e\u200e\u200e \u200ej\u200e\u200e\u200eoi\u200e\u200e\u200en.\u200e\u200e\u200e \u200e\u200e\u200eS\u200et\u200e\u200ea\u200e\u200e\u200er\u200e\u200e\u200et\u200e\u200ei\u200e\u200e\u200en\u200eg\u200e \u200e\u200ei\u200e\u200e\u200en\u200e\u200e\u200e \u200e\u200e\u200e2\u200e \u200e\u200e\u200em\u200e\u200ein\u200eu\u200e\u200e\u200et\u200e\u200ee\u200e\u200e\u200es!"
	*/

	cleanDesc := strings.Map(filterGraphic, e.Description)
	cleanTitle := strings.Map(filterGraphic, e.Title)

	// find era
	era := ""
	if match := rxEra.FindStringSubmatch(cleanDesc); match != nil {
		era = match[2]
	}

	// find host
	var hostUser *database.User
	if fields := strings.SplitN(cleanTitle, " hosted by ", 2); len(fields) == 2 {
		user, err := p.lookupUser(fields[1])
		if err != nil {
			return err
		}
		hostUser = &user
	}

	// start countdown of new game
	p.createNewGame(era, hostUser)
	p.LastKnownGame.CountdownStartTime = m.Timestamp

	return nil
}

func (p *Processor) processGameWinner(e discord.Embed) error {
	/*
		Embed title: "<:Crwn2:872850260756664350> **__WINNER!__**"

		Embed description:

		"**technobean**\n**Reward:** 6200 <:gold:695955554199142421>\n<:xp:860094804984725504> **1.5x XP multiplier!**"

	*/

	if !p.LastKnownIsGameRunning {
		if p.LastKnownGame.ID == 0 {
			log.Printf("WARNING: Ignoring first incomplete round data: %+v", e)
			return nil
		}
		log.Printf("ERROR: Seeing game winner data for an unknown game, failing: %+v", e)
		return errors.New("found game winner data when no game considered running")
	}

	// TODO - mark user as winner of this round?
	// TODO - add up reward & xp?

	p.LastKnownIsGameRunning = false

	return nil
}

var rxInteraction = regexp.MustCompile(`(?m)^(<:.+:\d+>)\s+\|\s+([^\n]+?)\s*$`)

func (p *Processor) processRound(e discord.Embed) error {
	/*
		Embed title: "__Round 1__"

		Embed description:

		"<:egg_launcher:1217934777030545418> | **thiocyanate** found a war torn rabbit merchant who dealt in arms and ammunition. They picked the __Egg Launcher__.\n<:easter_cauldron:1217935344910205030> | **divinelegacy** looted a __Easter Cauldron__ off another player who failed to use its special revival properties.\n<:K:861698472154759199> | **tokki\\_egg** accidentally dropped a basket of lizard eggs and the hatchlings immediately butchered ~~**leerdix**~~ and brought back the body as tribute.\n<:ra:696057593835290665> | **technobean** spent the day in a strange warehouse after being promised an eggquisite adventure.\n<:K:861698472154759199> | **toniiz\\.** passed over ~~**junki**~~. Then came back and shot them.\n<:ra:696057593835290665> | **luigisensei** spent the day in a strange warehouse after being promised an eggquisite adventure.\n<:K:861698472154759199> | **technobean** neglected to tell ~~**chiasacomfy**~~ their candy was expired. \n\nPlayers Left: 27"

	*/

	if !p.LastKnownIsGameRunning {
		if p.LastKnownGame.ID == 0 {
			log.Printf("WARNING: Ignoring first incomplete round data: %+v", e)
			return nil
		}
		log.Printf("ERROR: Seeing round data for an unknown game, failing: %+v", e)
		return errors.New("found round data when no game considered running")
	}

	// check if it is an event
	if strings.Contains(e.Title, " - ") {
		return p.processEventRound(e)
	}

	if err := p.storeCurrentRound(); err != nil {
		return err
	}

	for _, line := range rxInteraction.FindAllStringSubmatch(e.Description, -1) {
		line, userInteractions, err := p.extractUsers(line[2])
		if err != nil {
			return err
		}
		line, items, err := p.extractItems(line)
		if err != nil {
			return err
		}
		interactionMessage, err := p.lookupInteractionMessage(line, "")
		if err != nil {
			return err
		}
		i := database.Interaction{
			Message:      interactionMessage,
			MessageID:    interactionMessage.ID,
			Round:        p.LastKnownRound,
			RoundID:      p.LastKnownRound.ID,
			UserMentions: userInteractions,
			Items:        items,
		}
		if err := p.storeInteraction(&i); err != nil {
			return err
		}
	}

	p.createNewRound(p.LastKnownRound.RoundNumber + 1)

	return nil
}

var (
	rxXPMultiplier = regexp.MustCompile(`([\d\.]+)x\s+XP\s+multiplier`)
	rxPrize        = regexp.MustCompile(`\*\*Prize:\*\*\s+(\d+)`)
)

func (p *Processor) processGameStart(m discord.Message, e discord.Embed) error {
	/*
		Embed title: "Started a new Rumble Royale session"

		Embed description:

		"**Number of participants:** 30\n**Era:** <:easter_leghorse:1094271879616921680>Easter\n**Prize:** 6000 <:gold:695955554199142421>\n**Gold Per Kill:** 60 <:gold:695955554199142421>\n\n\n<:xp:860094804984725504> **1.5x XP multiplier!**"
	*/

	cleanDesc := strings.Map(filterGraphic, e.Description)

	p.LastKnownIsGameRunning = true
	p.LastKnownGame.StartTime = m.Timestamp

	// extract rewarded coins
	if match := rxPrize.FindStringSubmatch(cleanDesc); match != nil {
		prize, err := strconv.ParseUint(match[1], 10, 64)
		if err != nil {
			return err
		}
		p.LastKnownGame.RewardCoins = uint(prize)
	}

	// extract XP multiplier
	if match := rxXPMultiplier.FindStringSubmatch(cleanDesc); match != nil {
		multiplier64, err := strconv.ParseFloat(match[1], 32)
		if err != nil {
			return err
		}
		p.LastKnownGame.XPMultiplier = float32(multiplier64)
	}

	if err := p.storeCurrentGame(); err != nil {
		return err
	}

	return nil
}

func (p *Processor) processEventRound(e discord.Embed) error {
	/*
		Embed title: "__Round 1__ - STORM"

		Embed description:

		"A storm is gathering in the arena!\nPlayers are getting hit by lightning.\n\nThe following players died:\n<:S:861698472272986122> | ~~**toniiz\\.**~~\n<:S:861698472272986122> | ~~**chiasacomfy**~~\n<:S:861698472272986122> | ~~**pomegranede**~~\n<:S:861698472272986122> | ~~**technobean**~~\n<:S:861698472272986122> | ~~**f4b11**~~\n<:S:861698472272986122> | ~~**luigisensei**~~\n<:S:861698472272986122> | ~~**alexhero**~~\n<:S:861698472272986122> | ~~**leerdix**~~\n\nPlayers Left: 26"
	*/

	if !p.LastKnownIsGameRunning {
		if p.LastKnownGame.ID == 0 {
			log.Printf("WARNING: Ignoring first incomplete round data: %+v", e)
			return nil
		}
		log.Printf("ERROR: Seeing event round data for an unknown game, failing: %+v", e)
		return errors.New("found event round data when no game considered running")
	}

	if err := p.storeCurrentRound(); err != nil {
		return err
	}

	cleanDesc := strings.Map(filterGraphic, e.Description)
	cleanTitle := strings.Map(filterGraphic, e.Title)

	eventTitle := strings.SplitN(cleanTitle, " - ", 2)[1]
	eventDescription := strings.SplitN(cleanDesc, "\n\n", 2)[0]
	cleanDesc, userInteractions, err := p.extractUsers(cleanDesc)
	if err != nil {
		return err
	}
	_, items, err := p.extractItems(cleanDesc)
	if err != nil {
		return err
	}
	interactionMessage, err := p.lookupInteractionMessage(eventDescription, eventTitle)
	if err != nil {
		return err
	}
	i := database.Interaction{
		Message:      interactionMessage,
		MessageID:    interactionMessage.ID,
		Round:        p.LastKnownRound,
		RoundID:      p.LastKnownRound.ID,
		UserMentions: userInteractions,
		Items:        items,
	}
	if err := p.storeInteraction(&i); err != nil {
		return err
	}

	p.createNewRound(p.LastKnownRound.RoundNumber + 1)

	return nil
}

